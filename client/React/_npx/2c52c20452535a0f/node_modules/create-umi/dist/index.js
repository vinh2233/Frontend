var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  default: () => src_default
});
module.exports = __toCommonJS(src_exports);
var import_utils = require("@umijs/utils");
var import_fs = require("fs");
var import_path = require("path");
var import_template = require("./template");
var pkg = require("../package");
var DEFAULT_DATA = {
  pluginName: "umi-plugin-demo",
  email: "i@domain.com",
  author: "umijs",
  version: pkg.version,
  npmClient: "pnpm" /* pnpm */,
  registry: import_template.ERegistry.npm,
  withHusky: false,
  extraNpmrc: "",
  appTemplate: "app" /* app */
};
var src_default = async ({
  cwd,
  args,
  defaultData = DEFAULT_DATA
}) => {
  let [name] = args._;
  let npmClient = "pnpm" /* pnpm */;
  let registry = import_template.ERegistry.npm;
  let appTemplate = (defaultData == null ? void 0 : defaultData.appTemplate) || "app" /* app */;
  const { username, email } = await (0, import_utils.getGitInfo)();
  const author = email && username ? `${username} <${email}>` : "";
  let pluginName = `umi-plugin-${name || "demo"}`;
  let target = name ? (0, import_path.join)(cwd, name) : cwd;
  const { isCancel, text, select, intro, outro } = import_utils.clackPrompts;
  const exitPrompt = () => {
    outro(import_utils.chalk.red("Exit create-umi"));
    process.exit(1);
  };
  const setName = async () => {
    name = await text({
      message: "What's the target folder name?",
      initialValue: name || "my-app",
      validate: (value) => {
        if (!value.length) {
          return "Please input project name";
        }
        if (value != "." && import_utils.fsExtra.existsSync((0, import_path.join)(cwd, value))) {
          return `Folder ${value} already exists`;
        }
      }
    });
  };
  const selectAppTemplate = async () => {
    appTemplate = await select({
      message: "Pick Umi App Template",
      options: [
        { label: "Simple App", value: "app" /* app */ },
        {
          label: "Ant Design Pro",
          value: "max" /* max */,
          hint: "more plugins and ready to use features"
        },
        { label: "Vue Simple App", value: "vue-app" /* vueApp */ },
        {
          label: "Umi Plugin",
          value: "plugin" /* plugin */,
          hint: "for plugin development"
        }
      ],
      initialValue: "app" /* app */
    });
  };
  const selectNpmClient = async () => {
    npmClient = await select({
      message: "Pick Npm Client",
      options: [
        { label: "npm" /* npm */, value: "npm" /* npm */ },
        { label: "cnpm" /* cnpm */, value: "cnpm" /* cnpm */ },
        { label: "tnpm" /* tnpm */, value: "tnpm" /* tnpm */ },
        { label: "yarn" /* yarn */, value: "yarn" /* yarn */ },
        { label: "pnpm" /* pnpm */, value: "pnpm" /* pnpm */, hint: "recommended" }
      ],
      initialValue: "pnpm" /* pnpm */
    });
  };
  const selectRegistry = async () => {
    registry = await select({
      message: "Pick Npm Registry",
      options: [
        {
          label: "npm",
          value: import_template.ERegistry.npm
        },
        {
          label: "taobao",
          value: import_template.ERegistry.taobao,
          hint: "recommended for China"
        }
      ],
      initialValue: import_template.ERegistry.npm
    });
  };
  const internalTemplatePrompts = async () => {
    intro(import_utils.chalk.bgHex("#19BDD2")(" create-umi "));
    await setName();
    if (isCancel(name)) {
      exitPrompt();
    }
    target = (0, import_path.join)(cwd, name);
    await selectAppTemplate();
    if (isCancel(appTemplate)) {
      exitPrompt();
    }
    await selectNpmClient();
    if (isCancel(npmClient)) {
      exitPrompt();
    }
    await selectRegistry();
    if (isCancel(registry)) {
      exitPrompt();
    }
    const isPlugin = appTemplate === "plugin" /* plugin */;
    if (isPlugin) {
      pluginName = await text({
        message: `What's the plugin name?`,
        placeholder: pluginName,
        validate: (value) => {
          if (!(value == null ? void 0 : value.length)) {
            return "Please input plugin name";
          }
        }
      });
      if (isCancel(pluginName)) {
        exitPrompt();
      }
    }
    outro(import_utils.chalk.green(`You're all set!`));
  };
  const useDefaultData = !!args.default;
  const useExternalTemplate = !!args.template;
  switch (true) {
    case useExternalTemplate:
      await selectNpmClient();
      if (isCancel(npmClient)) {
        exitPrompt();
      }
      await selectRegistry();
      if (isCancel(registry)) {
        exitPrompt();
      }
      await (0, import_template.unpackTemplate)({
        template: args.template,
        dest: target,
        registry
      });
      break;
    default:
      if (!useDefaultData) {
        await internalTemplatePrompts();
      }
  }
  const version = pkg.version;
  const monorepoRoot = await detectMonorepoRoot({ target });
  const inMonorepo = !!monorepoRoot;
  const projectRoot = inMonorepo ? monorepoRoot : target;
  const shouldInitGit = args.git !== false;
  const withHusky = shouldInitGit && !inMonorepo;
  let pnpmExtraNpmrc = "";
  const isPnpm = npmClient === "pnpm" /* pnpm */;
  let pnpmMajorVersion;
  let pnpmVersion;
  if (isPnpm) {
    pnpmVersion = await getPnpmVersion();
    pnpmMajorVersion = parseInt(pnpmVersion.split(".")[0], 10);
    import_utils.logger.debug(`pnpm version: ${pnpmVersion}`);
    if (pnpmMajorVersion === 7) {
      pnpmExtraNpmrc = `strict-peer-dependencies=false`;
    }
  }
  const injectInternalTemplateFiles = async () => {
    const generator = new import_utils.BaseGenerator({
      path: (0, import_path.join)(__dirname, "..", "templates", appTemplate),
      target,
      slient: true,
      data: useDefaultData ? defaultData : {
        version: version.includes("-canary.") ? version : `^${version}`,
        npmClient,
        registry,
        author,
        email,
        withHusky,
        extraNpmrc: isPnpm ? pnpmExtraNpmrc : "",
        pluginName
      }
    });
    await generator.run();
  };
  if (!useExternalTemplate) {
    await injectInternalTemplateFiles();
  }
  const context = {
    inMonorepo,
    target,
    projectRoot
  };
  if (!withHusky) {
    await removeHusky(context);
  }
  if (inMonorepo) {
    await moveNpmrc(context);
  }
  if (shouldInitGit) {
    await initGit(context);
  } else {
    import_utils.logger.info(`Skip Git init`);
  }
  const isPnpm8 = pnpmMajorVersion === 8;
  const pnpmHighestResolutionMinVersion = "8.7.0";
  const isPnpmHighestResolution = isPnpm8 && import_utils.semver.gte(pnpmVersion, pnpmHighestResolutionMinVersion);
  if (!useDefaultData && args.install !== false) {
    if (isPnpm8 && !isPnpmHighestResolution) {
      await installAndUpdateWithPnpm(target);
    } else {
      (0, import_utils.installWithNpmClient)({ npmClient, cwd: target });
    }
  } else {
    import_utils.logger.info(`Skip install deps`);
    if (isPnpm8) {
      import_utils.logger.warn(
        import_utils.chalk.yellow(
          `You current using pnpm v8, it will install minimal version of dependencies`
        )
      );
      import_utils.logger.warn(
        import_utils.chalk.green(
          `Recommended that you run ${import_utils.chalk.bold.cyan(
            "pnpm up -L"
          )} to install latest version of dependencies`
        )
      );
    }
  }
};
async function detectMonorepoRoot(opts) {
  const { target } = opts;
  const rootPkg = await import_utils.pkgUp.pkgUp({ cwd: (0, import_path.dirname)(target) });
  if (!rootPkg) {
    return null;
  }
  const rootDir = (0, import_path.dirname)(rootPkg);
  if ((0, import_utils.tryPaths)([
    (0, import_path.join)(rootDir, "lerna.json"),
    (0, import_path.join)(rootDir, "pnpm-workspace.yaml")
  ])) {
    return rootDir;
  }
  return null;
}
async function moveNpmrc(opts) {
  const { target, projectRoot } = opts;
  const sourceNpmrc = (0, import_path.join)(target, "./.npmrc");
  const targetNpmrc = (0, import_path.join)(projectRoot, "./.npmrc");
  if (!(0, import_fs.existsSync)(targetNpmrc)) {
    await import_utils.fsExtra.copyFile(sourceNpmrc, targetNpmrc);
  }
  await import_utils.fsExtra.remove(sourceNpmrc);
}
async function initGit(opts) {
  const { projectRoot } = opts;
  const isGit = (0, import_fs.existsSync)((0, import_path.join)(projectRoot, ".git"));
  if (isGit)
    return;
  try {
    await import_utils.execa.execa("git", ["init"], { cwd: projectRoot });
  } catch {
    import_utils.logger.error(`Initial the git repo failed`);
  }
}
async function removeHusky(opts) {
  const dir = (0, import_path.join)(opts.target, "./.husky");
  if ((0, import_fs.existsSync)(dir)) {
    await import_utils.fsExtra.remove(dir);
  }
}
async function installAndUpdateWithPnpm(cwd) {
  await import_utils.execa.execa("pnpm", ["up", "-L"], { cwd, stdio: "inherit" });
}
async function getPnpmVersion() {
  try {
    const { stdout } = await import_utils.execa.execa("pnpm", ["--version"]);
    return stdout.trim();
  } catch (e) {
    throw new Error("Please install pnpm first", { cause: e });
  }
}
